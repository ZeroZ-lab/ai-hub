# 02. ä»£ç ç¤ºä¾‹ - å®æˆ˜æ¼”ç¤º

> é€šè¿‡å®é™…ä»£ç ç†è§£ Session ç®¡ç†ã€Prompt Caching å’Œä¸Šä¸‹æ–‡å¤„ç†

## ğŸ¯ æœ¬ç« ç›®æ ‡

- å­¦ä¹  Session æŒä¹…åŒ–çš„å®ç°
- æŒæ¡ Prompt Caching çš„ä½¿ç”¨æ–¹æ³•
- äº†è§£ Token è®¡æ•°å’Œä¸Šä¸‹æ–‡ç®¡ç†
- å®è·µå¤šè½®å¯¹è¯å¤„ç†

---

## 1. Session ç®¡ç†å®ç°

### 1.1 åŸºç¡€ Session ç±»

```python
import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional

class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨ - æŒä¹…åŒ–å¯¹è¯å†å²"""
    
    def __init__(self, storage_dir: str = "./sessions"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(exist_ok=True)
    
    def create_session(self, user_id: str = "default") -> str:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_id = f"sess_{uuid.uuid4().hex[:8]}"
        session_data = {
            "session_id": session_id,
            "user_id": user_id,
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat(),
            "messages": []
        }
        self._save_session(session_id, session_data)
        return session_id
    
    def add_message(self, session_id: str, role: str, content: str):
        """æ·»åŠ æ¶ˆæ¯åˆ°ä¼šè¯"""
        session = self.load_session(session_id)
        session["messages"].append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        session["updated_at"] = datetime.now().isoformat()
        self._save_session(session_id, session)
    
    def load_session(self, session_id: str) -> Dict:
        """åŠ è½½ä¼šè¯æ•°æ®"""
        session_file = self.storage_dir / f"{session_id}.json"
        if not session_file.exists():
            raise ValueError(f"Session {session_id} not found")
        
        with open(session_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def get_messages(self, session_id: str) -> List[Dict]:
        """è·å–ä¼šè¯æ¶ˆæ¯åˆ—è¡¨"""
        session = self.load_session(session_id)
        return session["messages"]
    
    def list_sessions(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰ä¼šè¯"""
        return [f.stem for f in self.storage_dir.glob("sess_*.json")]
    
    def _save_session(self, session_id: str, data: Dict):
        """ä¿å­˜ä¼šè¯æ•°æ®"""
        session_file = self.storage_dir / f"{session_id}.json"
        with open(session_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
```

### 1.2 ä½¿ç”¨ç¤ºä¾‹

```python
# åˆ›å»ºä¼šè¯ç®¡ç†å™¨
manager = SessionManager()

# å¼€å§‹æ–°å¯¹è¯
session_id = manager.create_session(user_id="alice")
print(f"åˆ›å»ºä¼šè¯: {session_id}")

# æ·»åŠ å¯¹è¯æ¶ˆæ¯
manager.add_message(session_id, "user", "ä½ å¥½ï¼Œæˆ‘æƒ³å­¦ä¹  Agent å¼€å‘")
manager.add_message(session_id, "assistant", "å¾ˆé«˜å…´å¸®åŠ©æ‚¨ï¼Agent æ˜¯...")

# åç»­ç»§ç»­å¯¹è¯
manager.add_message(session_id, "user", "èƒ½è¯¦ç»†è®²è®² Session ç®¡ç†å—ï¼Ÿ")
manager.add_message(session_id, "assistant", "å½“ç„¶å¯ä»¥ï¼Session ç®¡ç†...")

# è·å–å®Œæ•´å†å²
messages = manager.get_messages(session_id)
for msg in messages:
    print(f"[{msg['role']}]: {msg['content']}")

# åˆ—å‡ºæ‰€æœ‰ä¼šè¯
all_sessions = manager.list_sessions()
print(f"æ€»å…± {len(all_sessions)} ä¸ªä¼šè¯")
```

---

## 2. Claude Agent SDK Session é›†æˆ

### 2.1 å¸¦ Session çš„ Agent

```python
from claude_agent_sdk import Agent, Tool
from session_manager import SessionManager

class ConversationalAgent:
    """æ”¯æŒä¼šè¯æŒä¹…åŒ–çš„ Agent"""
    
    def __init__(self, api_key: str):
        self.agent = Agent(api_key=api_key)
        self.session_manager = SessionManager()
        self.current_session = None
    
    def start_new_conversation(self, user_id: str = "default") -> str:
        """å¼€å§‹æ–°å¯¹è¯"""
        self.current_session = self.session_manager.create_session(user_id)
        print(f"âœ¨ å¼€å§‹æ–°å¯¹è¯: {self.current_session}")
        return self.current_session
    
    def resume_conversation(self, session_id: str):
        """æ¢å¤ä¹‹å‰çš„å¯¹è¯"""
        # éªŒè¯ä¼šè¯å­˜åœ¨
        self.session_manager.load_session(session_id)
        self.current_session = session_id
        print(f"ğŸ”„ æ¢å¤å¯¹è¯: {session_id}")
    
    def chat(self, user_message: str) -> str:
        """å‘é€æ¶ˆæ¯å¹¶è·å–å›å¤"""
        if not self.current_session:
            raise ValueError("æ²¡æœ‰æ´»åŠ¨ä¼šè¯ï¼Œè¯·å…ˆåˆ›å»ºæˆ–æ¢å¤ä¼šè¯")
        
        # ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
        self.session_manager.add_message(
            self.current_session, 
            "user", 
            user_message
        )
        
        # è·å–å†å²æ¶ˆæ¯
        history = self.session_manager.get_messages(self.current_session)
        
        # è½¬æ¢ä¸º Claude API æ ¼å¼
        messages = [
            {"role": msg["role"], "content": msg["content"]}
            for msg in history
        ]
        
        # è°ƒç”¨ Agentï¼ˆä¼ å…¥å®Œæ•´å†å²ï¼‰
        response = self.agent.run(messages=messages)
        
        # ä¿å­˜ AI å“åº”
        assistant_message = response.content[0].text
        self.session_manager.add_message(
            self.current_session,
            "assistant",
            assistant_message
        )
        
        return assistant_message
```

### 2.2 ä½¿ç”¨ç¤ºä¾‹

```python
# åˆå§‹åŒ– Agent
agent = ConversationalAgent(api_key="your-api-key")

# åœºæ™¯ 1ï¼šæ–°å¯¹è¯
session_id = agent.start_new_conversation(user_id="alice")
response1 = agent.chat("ä»€ä¹ˆæ˜¯ Prompt Cachingï¼Ÿ")
print(response1)

response2 = agent.chat("å®ƒèƒ½èŠ‚çœå¤šå°‘æˆæœ¬ï¼Ÿ")  # Agent è®°å¾—ä¸Šä¸‹æ–‡ï¼
print(response2)

# åœºæ™¯ 2ï¼šç¨åæ¢å¤å¯¹è¯
agent_new = ConversationalAgent(api_key="your-api-key")
agent_new.resume_conversation(session_id)
response3 = agent_new.chat("èƒ½å†è¯¦ç»†è§£é‡Šä¸€ä¸‹å—ï¼Ÿ")  # ç»§ç»­ä¹‹å‰çš„è¯é¢˜
print(response3)
```

---

## 3. Prompt Caching å®æˆ˜

### 3.1 åŸºç¡€ Caching ç¤ºä¾‹

```python
import anthropic

client = anthropic.Anthropic(api_key="your-api-key")

# å‡†å¤‡å¤§é‡å›ºå®šå†…å®¹ï¼ˆå¦‚æ–‡æ¡£ï¼‰
large_document = """
# Claude Agent SDK å®Œæ•´æ–‡æ¡£

## 1. ä»‹ç»
Claude Agent SDK æ˜¯...

## 2. æ ¸å¿ƒæ¦‚å¿µ
...ï¼ˆå‡è®¾è¿™é‡Œæœ‰ 10,000 tokens çš„å†…å®¹ï¼‰
"""

# ç¬¬ä¸€æ¬¡è¯·æ±‚ - å»ºç«‹ç¼“å­˜
response1 = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": large_document,
                    "cache_control": {"type": "ephemeral"}  # æ ‡è®°ä¸ºå¯ç¼“å­˜
                },
                {
                    "type": "text",
                    "text": "è¿™ä¸ªæ–‡æ¡£çš„ä¸»è¦å†…å®¹æ˜¯ä»€ä¹ˆï¼Ÿ"
                }
            ]
        }
    ]
)

# æŸ¥çœ‹ token ä½¿ç”¨æƒ…å†µ
print(f"è¾“å…¥ tokens: {response1.usage.input_tokens}")
print(f"ç¼“å­˜åˆ›å»º tokens: {response1.usage.cache_creation_input_tokens}")
print(f"ç¼“å­˜è¯»å– tokens: {response1.usage.cache_read_input_tokens}")

# ç¬¬äºŒæ¬¡è¯·æ±‚ - ç¼“å­˜å‘½ä¸­ï¼
response2 = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": large_document,  # ç›¸åŒå†…å®¹
                    "cache_control": {"type": "ephemeral"}
                },
                {
                    "type": "text",
                    "text": "ç¬¬ä¸‰ç« è®²äº†ä»€ä¹ˆï¼Ÿ"  # æ–°é—®é¢˜
                }
            ]
        }
    ]
)

print(f"\nç¬¬äºŒæ¬¡è¯·æ±‚:")
print(f"è¾“å…¥ tokens: {response2.usage.input_tokens}")
print(f"ç¼“å­˜è¯»å– tokens: {response2.usage.cache_read_input_tokens}")  # å¤§éƒ¨åˆ†ä»ç¼“å­˜è¯»å–ï¼
```

### 3.2 å¤šè½®å¯¹è¯ä¸­çš„ Caching

```python
def cached_qa_bot(document: str):
    """å¸¦ç¼“å­˜çš„é—®ç­”æœºå™¨äºº"""
    
    conversation_history = []
    
    def ask_question(question: str) -> str:
        # æ„å»ºæ¶ˆæ¯ï¼ˆæ–‡æ¡£ + å†å² + æ–°é—®é¢˜ï¼‰
        messages = [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": document,
                        "cache_control": {"type": "ephemeral"}  # æ–‡æ¡£ç¼“å­˜
                    },
                    {
                        "type": "text",
                        "text": f"åŸºäºä»¥ä¸Šæ–‡æ¡£å›ç­”é—®é¢˜ï¼š{question}"
                    }
                ]
            }
        ]
        
        # æ·»åŠ å†å²å¯¹è¯
        for turn in conversation_history:
            messages.extend([
                {"role": "user", "content": turn["question"]},
                {"role": "assistant", "content": turn["answer"]}
            ])
        
        # å‘é€è¯·æ±‚
        response = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            messages=messages
        )
        
        answer = response.content[0].text
        
        # ä¿å­˜å†å²
        conversation_history.append({
            "question": question,
            "answer": answer
        })
        
        return answer
    
    return ask_question

# ä½¿ç”¨ç¤ºä¾‹
qa = cached_qa_bot(large_document)

answer1 = qa("æ–‡æ¡£ä¸»è¦è®²ä»€ä¹ˆï¼Ÿ")
answer2 = qa("ç¬¬äºŒç« çš„é‡ç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ")  # æ–‡æ¡£å·²ç¼“å­˜ï¼ŒèŠ‚çœæˆæœ¬ï¼
answer3 = qa("èƒ½ä¸¾ä¸ªä¾‹å­å—ï¼Ÿ")
```

---

## 4. Token è®¡æ•°ä¸ç®¡ç†

### 4.1 Token è®¡æ•°å·¥å…·

```python
import tiktoken

def count_tokens(text: str, model: str = "claude-3-5-sonnet-20241022") -> int:
    """è®¡ç®—æ–‡æœ¬çš„ token æ•°é‡"""
    # Claude ä½¿ç”¨ cl100k_base encoding
    encoding = tiktoken.get_encoding("cl100k_base")
    tokens = encoding.encode(text)
    return len(tokens)

# ä½¿ç”¨ç¤ºä¾‹
text = "ä½ å¥½ï¼Œä¸–ç•Œï¼Hello, World!"
token_count = count_tokens(text)
print(f"æ–‡æœ¬: {text}")
print(f"Token æ•°: {token_count}")
```

### 4.2 ä¸Šä¸‹æ–‡é™åˆ¶æ£€æŸ¥

```python
MAX_CONTEXT_TOKENS = 200_000
MAX_OUTPUT_TOKENS = 4_096

def check_context_limit(messages: List[Dict]) -> bool:
    """æ£€æŸ¥æ˜¯å¦è¶…å‡ºä¸Šä¸‹æ–‡é™åˆ¶"""
    total_tokens = 0
    
    for msg in messages:
        content = msg.get("content", "")
        if isinstance(content, list):
            # å¤„ç†å¤šéƒ¨åˆ†å†…å®¹
            for part in content:
                if part.get("type") == "text":
                    total_tokens += count_tokens(part["text"])
        else:
            total_tokens += count_tokens(content)
    
    # é¢„ç•™è¾“å‡ºç©ºé—´
    available_tokens = MAX_CONTEXT_TOKENS - MAX_OUTPUT_TOKENS
    
    if total_tokens > available_tokens:
        print(f"âš ï¸  ä¸Šä¸‹æ–‡è¿‡å¤§: {total_tokens} tokens (é™åˆ¶: {available_tokens})")
        return False
    
    print(f"âœ… ä¸Šä¸‹æ–‡æ­£å¸¸: {total_tokens}/{available_tokens} tokens")
    return True
```

### 4.3 æ™ºèƒ½å‹ç¼©ç­–ç•¥

```python
def compress_context(messages: List[Dict], max_tokens: int = 100_000) -> List[Dict]:
    """æ™ºèƒ½å‹ç¼©ä¸Šä¸‹æ–‡"""
    
    # è®¡ç®—å½“å‰ token æ•°
    current_tokens = sum(count_tokens(msg.get("content", "")) for msg in messages)
    
    if current_tokens <= max_tokens:
        return messages  # ä¸éœ€è¦å‹ç¼©
    
    # ç­–ç•¥ 1: ä¿ç•™æœ€è¿‘ N æ¡æ¶ˆæ¯
    recent_messages = messages[-10:]  # ä¿ç•™æœ€å 10 æ¡
    recent_tokens = sum(count_tokens(msg.get("content", "")) for msg in recent_messages)
    
    if recent_tokens <= max_tokens:
        print(f"ğŸ”§ å‹ç¼©: {len(messages)} -> {len(recent_messages)} æ¡æ¶ˆæ¯")
        return recent_messages
    
    # ç­–ç•¥ 2: ç”Ÿæˆæ‘˜è¦ï¼ˆéœ€è¦è°ƒç”¨ LLMï¼‰
    summary_prompt = f"""
    è¯·æ€»ç»“ä»¥ä¸‹å¯¹è¯çš„å…³é”®ä¿¡æ¯ï¼ˆä¿æŒåœ¨ 1000 tokens å†…ï¼‰ï¼š
    
    {format_messages(messages[:-10])}
    """
    
    summary = get_summary(summary_prompt)  # è°ƒç”¨ LLM ç”Ÿæˆæ‘˜è¦
    
    compressed_messages = [
        {"role": "system", "content": f"ä¹‹å‰å¯¹è¯æ‘˜è¦ï¼š{summary}"},
        *recent_messages
    ]
    
    print(f"ğŸ”§ å‹ç¼© + æ‘˜è¦: {len(messages)} -> æ‘˜è¦ + {len(recent_messages)} æ¡æ¶ˆæ¯")
    return compressed_messages
```

---

## 5. æ»‘åŠ¨çª—å£å®ç°

### 5.1 ç®€å•æ»‘åŠ¨çª—å£

```python
class SlidingWindowAgent:
    """ä½¿ç”¨æ»‘åŠ¨çª—å£ç®¡ç†ä¸Šä¸‹æ–‡çš„ Agent"""
    
    def __init__(self, api_key: str, window_size: int = 10):
        self.agent = Agent(api_key=api_key)
        self.window_size = window_size
        self.all_messages = []
    
    def chat(self, user_message: str) -> str:
        # æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
        self.all_messages.append({
            "role": "user",
            "content": user_message
        })
        
        # è·å–çª—å£å†…çš„æ¶ˆæ¯
        window_messages = self.all_messages[-self.window_size:]
        
        # è°ƒç”¨ Agent
        response = self.agent.run(messages=window_messages)
        assistant_message = response.content[0].text
        
        # ä¿å­˜ AI å“åº”
        self.all_messages.append({
            "role": "assistant",
            "content": assistant_message
        })
        
        print(f"ğŸ“Š æ€»æ¶ˆæ¯: {len(self.all_messages)}, çª—å£: {len(window_messages)}")
        
        return assistant_message
```

### 5.2 Token-aware æ»‘åŠ¨çª—å£

```python
class TokenAwareWindow:
    """åŸºäº token æ•°é‡çš„æ™ºèƒ½æ»‘åŠ¨çª—å£"""
    
    def __init__(self, max_tokens: int = 100_000):
        self.max_tokens = max_tokens
        self.all_messages = []
    
    def get_window(self) -> List[Dict]:
        """è·å–ç¬¦åˆ token é™åˆ¶çš„æ¶ˆæ¯çª—å£"""
        window = []
        total_tokens = 0
        
        # ä»æœ€æ–°æ¶ˆæ¯å¼€å§‹å€’åºæ·»åŠ 
        for msg in reversed(self.all_messages):
            msg_tokens = count_tokens(msg["content"])
            
            if total_tokens + msg_tokens > self.max_tokens:
                break  # è¶…å‡ºé™åˆ¶ï¼Œåœæ­¢æ·»åŠ 
            
            window.insert(0, msg)  # æ’å…¥åˆ°å¼€å¤´ä¿æŒé¡ºåº
            total_tokens += msg_tokens
        
        print(f"ğŸ“Š çª—å£: {len(window)}/{len(self.all_messages)} æ¶ˆæ¯, {total_tokens} tokens")
        return window
```

---

## 6. å®Œæ•´ç¤ºä¾‹ï¼šæ™ºèƒ½é—®ç­”ç³»ç»Ÿ

```python
class SmartQASystem:
    """é›†æˆ Sessionã€Caching å’Œä¸Šä¸‹æ–‡ç®¡ç†çš„æ™ºèƒ½é—®ç­”ç³»ç»Ÿ"""
    
    def __init__(self, api_key: str, knowledge_base: str):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.knowledge_base = knowledge_base  # çŸ¥è¯†åº“ï¼ˆä¼šè¢«ç¼“å­˜ï¼‰
        self.session_manager = SessionManager()
        self.current_session = None
    
    def start_session(self, user_id: str = "default"):
        """å¼€å§‹æ–°ä¼šè¯"""
        self.current_session = self.session_manager.create_session(user_id)
        return self.current_session
    
    def ask(self, question: str) -> str:
        """æé—®"""
        if not self.current_session:
            self.start_session()
        
        # è·å–å†å²
        history = self.session_manager.get_messages(self.current_session)
        
        # æ„å»ºæ¶ˆæ¯ï¼ˆçŸ¥è¯†åº“ + å†å² + æ–°é—®é¢˜ï¼‰
        messages = []
        
        # é¦–æ¡æ¶ˆæ¯åŒ…å«çŸ¥è¯†åº“ï¼ˆç¼“å­˜ï¼‰
        if len(history) == 0:
            messages.append({
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": self.knowledge_base,
                        "cache_control": {"type": "ephemeral"}
                    },
                    {
                        "type": "text",
                        "text": f"åŸºäºä»¥ä¸ŠçŸ¥è¯†åº“å›ç­”ï¼š{question}"
                    }
                ]
            })
        else:
            # åç»­æ¶ˆæ¯ï¼šçŸ¥è¯†åº“ + å®Œæ•´å†å²
            kb_msg = {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": self.knowledge_base,
                        "cache_control": {"type": "ephemeral"}
                    }
                ]
            }
            
            # è½¬æ¢å†å²ä¸ºå¯¹è¯æ ¼å¼
            for msg in history:
                messages.append({
                    "role": msg["role"],
                    "content": msg["content"]
                })
            
            # æ’å…¥çŸ¥è¯†åº“åˆ°å¼€å¤´
            messages.insert(0, kb_msg)
            
            # æ·»åŠ æ–°é—®é¢˜
            messages.append({
                "role": "user",
                "content": question
            })
        
        # è°ƒç”¨ API
        response = self.client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=2048,
            messages=messages
        )
        
        answer = response.content[0].text
        
        # ä¿å­˜åˆ° session
        self.session_manager.add_message(self.current_session, "user", question)
        self.session_manager.add_message(self.current_session, "assistant", answer)
        
        # æ‰“å° token ä½¿ç”¨æƒ…å†µ
        self._print_usage(response.usage)
        
        return answer
    
    def _print_usage(self, usage):
        """æ‰“å° token ä½¿ç”¨ç»Ÿè®¡"""
        print(f"\nğŸ“Š Token ä½¿ç”¨:")
        print(f"  è¾“å…¥: {usage.input_tokens}")
        if hasattr(usage, 'cache_read_input_tokens'):
            print(f"  ç¼“å­˜è¯»å–: {usage.cache_read_input_tokens} âœ¨")
        if hasattr(usage, 'cache_creation_input_tokens'):
            print(f"  ç¼“å­˜åˆ›å»º: {usage.cache_creation_input_tokens}")
        print(f"  è¾“å‡º: {usage.output_tokens}\n")

# ä½¿ç”¨ç¤ºä¾‹
knowledge_base = """
# Claude Agent SDK æ–‡æ¡£

## æ ¸å¿ƒåŠŸèƒ½
1. Tool å®šä¹‰å’Œæ³¨å†Œ
2. Agent æ‰§è¡Œå¾ªç¯
3. å¤šè½®å¯¹è¯ç®¡ç†
...ï¼ˆå¤§é‡å†…å®¹ï¼‰
"""

qa_system = SmartQASystem(api_key="your-api-key", knowledge_base=knowledge_base)

# å¼€å§‹å¯¹è¯
session_id = qa_system.start_session(user_id="alice")

# å¤šè½®é—®ç­”
answer1 = qa_system.ask("SDK çš„æ ¸å¿ƒåŠŸèƒ½æœ‰å“ªäº›ï¼Ÿ")
print(f"å›ç­” 1: {answer1}\n")

answer2 = qa_system.ask("èƒ½è¯¦ç»†è®²è®² Tool æ³¨å†Œå—ï¼Ÿ")  # çŸ¥è¯†åº“å·²ç¼“å­˜ï¼
print(f"å›ç­” 2: {answer2}\n")

answer3 = qa_system.ask("æœ‰ç¤ºä¾‹ä»£ç å—ï¼Ÿ")
print(f"å›ç­” 3: {answer3}")
```

---

## 7. å°ç»“

### å…³é”®ä»£ç æ¨¡å¼

| åŠŸèƒ½ | æ ¸å¿ƒä»£ç  |
|------|---------|
| **Session ä¿å­˜** | `json.dump(session_data, file)` |
| **Session åŠ è½½** | `json.load(file)` |
| **Prompt Caching** | `"cache_control": {"type": "ephemeral"}` |
| **Token è®¡æ•°** | `tiktoken.get_encoding("cl100k_base")` |
| **æ»‘åŠ¨çª—å£** | `messages[-window_size:]` |

### æœ€ä½³å®è·µ

1. âœ… **å§‹ç»ˆæŒä¹…åŒ–é‡è¦å¯¹è¯**
2. âœ… **å¤§æ–‡æ¡£å¿…é¡»ä½¿ç”¨ Caching**
3. âœ… **å®šæœŸæ£€æŸ¥ token ä½¿ç”¨é‡**
4. âœ… **è¶…å‡ºé™åˆ¶æ—¶æ™ºèƒ½å‹ç¼©**
5. âœ… **ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡**

---

## ä¸‹ä¸€æ­¥

- **[03_æœ€ä½³å®è·µ.md](03_æœ€ä½³å®è·µ.md)** - ç”Ÿäº§ç¯å¢ƒç»éªŒ
- **[Project 1: Session Manager](../projects/project_01_session_manager/)** - å®æˆ˜é¡¹ç›®
