# Module 2 - 最佳实践：工具使用的安全与效率

> 本文档总结核心工具使用中的安全考虑、最佳实践和常见陷阱。

## 安全第一

### ⚠️ 工具的风险等级

不同工具有不同的风险级别，需要相应的安全策略：

| 工具 | 风险等级 | 潜在危害 | 安全策略 |
|------|----------|----------|----------|
| **Read** | 🟢 低 | 可能泄露敏感信息 | 限制可读目录 |
| **Write** | 🟡 中 | 覆盖重要文件 | 白名单 + 备份 |
| **Bash** | 🔴 高 | 执行任意命令 | 严格过滤 |

### 黄金法则

1. **最小权限原则**：只启用必需的工具
2. **白名单优于黑名单**：明确允许的比试图阻止禁止的更安全
3. **人工确认高危操作**：删除、覆盖等操作应有确认机制

---

## 权限控制最佳实践

### 1. 按需启用工具

```python
# ❌ 不好：启用所有工具
options = ClaudeAgentOptions(
    allowed_tools=["Read", "Write", "Bash"]  # 权限过大
)

# ✅ 好：只启用需要的
# 场景1：只需要分析文件
options = ClaudeAgentOptions(allowed_tools=["Read"])

# 场景2：需要生成报告
options = ClaudeAgentOptions(allowed_tools=["Read", "Write"])

# 场景3：需要检查系统
options = ClaudeAgentOptions(allowed_tools=["Bash"])
```

### 2. 实现安全的权限检查器

```python
"""
最佳实践：完整的权限检查器
"""

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ToolPermissionContext,
    PermissionResultAllow,
    PermissionResultDeny
)

# 配置：可自定义的安全策略
SECURITY_CONFIG = {
    # Read 工具配置
    "read": {
        "allowed_paths": ["./", "/home/user/projects"],
        "denied_patterns": [".env", ".git/config", "secrets", "password"],
    },
    # Write 工具配置
    "write": {
        "allowed_paths": ["./output", "./reports", "./temp"],
        "denied_patterns": [".env", "config.json", "__pycache__"],
        "max_file_size": 1024 * 1024,  # 1MB
    },
    # Bash 工具配置
    "bash": {
        "allowed_commands": [
            "ls", "cat", "head", "tail", "wc",
            "pwd", "echo", "date", "git status",
            "git log", "git diff", "python --version"
        ],
        "denied_patterns": [
            "rm -rf", "rm -r", "sudo", "chmod",
            "> /dev", "mkfs", "dd if=", "curl | sh",
            "wget -O - | sh", "eval", "exec"
        ],
    }
}

async def secure_permission_checker(
    tool_name: str, 
    tool_input: dict, 
    context: ToolPermissionContext
):
    """安全的权限检查器"""
    
    if tool_name == "Read":
        return check_read_permission(tool_input)
    elif tool_name == "Write":
        return check_write_permission(tool_input)
    elif tool_name == "Bash":
        return check_bash_permission(tool_input)
    
    # 未知工具默认拒绝
    return PermissionResultDeny(
        behavior="deny",
        message=f"未知工具: {tool_name}"
    )

def check_read_permission(tool_input: dict):
    """检查读取权限"""
    file_path = tool_input.get("file_path", "")
    config = SECURITY_CONFIG["read"]
    
    # 检查禁止的模式
    for pattern in config["denied_patterns"]:
        if pattern in file_path.lower():
            return PermissionResultDeny(
                behavior="deny",
                message=f"不允许读取包含 '{pattern}' 的文件"
            )
    
    return PermissionResultAllow(behavior="allow")

def check_write_permission(tool_input: dict):
    """检查写入权限"""
    file_path = tool_input.get("file_path", "")
    content = tool_input.get("content", "")
    config = SECURITY_CONFIG["write"]
    
    # 检查文件大小
    if len(content) > config["max_file_size"]:
        return PermissionResultDeny(
            behavior="deny",
            message="文件内容超过大小限制"
        )
    
    # 检查禁止的模式
    for pattern in config["denied_patterns"]:
        if pattern in file_path.lower():
            return PermissionResultDeny(
                behavior="deny",
                message=f"不允许写入: {pattern}"
            )
    
    # 检查是否在允许的目录
    allowed = any(file_path.startswith(p) for p in config["allowed_paths"])
    if not allowed:
        return PermissionResultDeny(
            behavior="deny",
            message=f"只允许写入: {config['allowed_paths']}"
        )
    
    return PermissionResultAllow(behavior="allow")

def check_bash_permission(tool_input: dict):
    """检查 Bash 命令权限"""
    command = tool_input.get("command", "")
    config = SECURITY_CONFIG["bash"]
    
    # 检查危险模式（优先）
    for pattern in config["denied_patterns"]:
        if pattern in command:
            return PermissionResultDeny(
                behavior="deny",
                message=f"命令包含危险模式: {pattern}"
            )
    
    # 检查是否在白名单（严格模式）
    allowed = any(command.startswith(cmd) for cmd in config["allowed_commands"])
    if not allowed:
        return PermissionResultDeny(
            behavior="deny",
            message="命令不在白名单中"
        )
    
    return PermissionResultAllow(behavior="allow")
```

### 3. 使用 Hooks 进行审计

```python
"""
最佳实践：使用 Hooks 记录所有操作
"""

import datetime
import json
from claude_agent_sdk import ClaudeAgentOptions, HookMatcher

# 操作日志
audit_log = []

async def pre_tool_audit(tool_name: str, tool_input: dict):
    """工具执行前的审计钩子"""
    log_entry = {
        "timestamp": datetime.datetime.now().isoformat(),
        "event": "PRE_TOOL_USE",
        "tool": tool_name,
        "input": tool_input
    }
    audit_log.append(log_entry)
    print(f"📋 审计: {tool_name} - {json.dumps(tool_input)[:100]}")
    return {}  # 不修改，只记录

async def post_tool_audit(tool_name: str, tool_result: str):
    """工具执行后的审计钩子"""
    log_entry = {
        "timestamp": datetime.datetime.now().isoformat(),
        "event": "POST_TOOL_USE",
        "tool": tool_name,
        "result_length": len(tool_result)
    }
    audit_log.append(log_entry)
    return {}

# 配置 Hooks
options = ClaudeAgentOptions(
    allowed_tools=["Read", "Write", "Bash"],
    hooks={
        "PreToolUse": [
            HookMatcher(matcher="*", hooks=[pre_tool_audit])
        ],
        "PostToolUse": [
            HookMatcher(matcher="*", hooks=[post_tool_audit])
        ]
    }
)

def save_audit_log(filename="audit.json"):
    """保存审计日志"""
    with open(filename, "w") as f:
        json.dump(audit_log, f, indent=2, ensure_ascii=False)
```

---

## 错误处理最佳实践

### 1. 优雅的错误处理

```python
"""
最佳实践：错误处理
"""

import asyncio
from claude_agent_sdk import query, ClaudeAgentOptions

async def robust_query(prompt: str, options: ClaudeAgentOptions, max_retries: int = 3):
    """带重试机制的查询"""
    
    for attempt in range(max_retries):
        try:
            results = []
            async for message in query(prompt=prompt, options=options):
                results.append(message)
                
                # 处理工具错误
                if hasattr(message, 'error'):
                    print(f"⚠️ 工具错误: {message.error}")
                    # 可以选择继续或中断
                    
            return results
            
        except ConnectionError as e:
            print(f"🔄 连接错误，重试 {attempt + 1}/{max_retries}: {e}")
            await asyncio.sleep(2 ** attempt)  # 指数退避
            
        except Exception as e:
            print(f"❌ 错误: {e}")
            if attempt == max_retries - 1:
                raise
    
    return []
```

### 2. 处理工具执行失败

```python
"""
工具执行失败的处理策略
"""

async def handle_tool_response(message):
    """处理工具响应"""
    
    if message.type == "tool_result":
        # 检查是否有错误
        if hasattr(message, 'is_error') and message.is_error:
            print(f"⚠️ 工具执行失败: {message.result}")
            
            # 策略1: 记录并继续
            log_error(message)
            
            # 策略2: 通知用户
            # notify_user(f"操作失败: {message.result}")
            
            # 策略3: 尝试替代方案
            # return await try_alternative(message)
            
    elif message.type == "text":
        print(message.text)
```

### 3. 超时处理

```python
"""
超时处理
"""

import asyncio
from claude_agent_sdk import query, ClaudeAgentOptions

async def query_with_timeout(prompt: str, options: ClaudeAgentOptions, timeout: int = 60):
    """带超时的查询"""
    
    async def _do_query():
        results = []
        async for msg in query(prompt=prompt, options=options):
            results.append(msg)
        return results
    
    try:
        return await asyncio.wait_for(_do_query(), timeout=timeout)
    except asyncio.TimeoutError:
        print(f"⏰ 查询超时（{timeout}秒）")
        return []
```

---

## 性能优化

### 1. 减少不必要的工具调用

```python
# ❌ 不好：让 Agent 猜测文件路径
prompt = "帮我找到配置文件并读取"

# ✅ 好：提供明确的信息
prompt = """
请读取 config/settings.json 文件，
这是项目的主配置文件，位于 config/ 目录下。
"""
```

### 2. 批量操作

```python
# ❌ 不好：多次单独请求
for file in files:
    await query(f"读取 {file}", options)

# ✅ 好：一次批量请求
prompt = f"""
请执行以下操作：
1. 读取这些文件: {', '.join(files)}
2. 统一返回分析结果
"""
await query(prompt, options)
```

### 3. 结果缓存

```python
"""
工具结果缓存
"""

from functools import lru_cache
import hashlib

# 简单的内存缓存
_cache = {}

async def cached_read(file_path: str, options: ClaudeAgentOptions):
    """缓存文件读取结果"""
    
    cache_key = hashlib.md5(file_path.encode()).hexdigest()
    
    if cache_key in _cache:
        print(f"📦 缓存命中: {file_path}")
        return _cache[cache_key]
    
    # 实际读取
    result = []
    async for msg in query(f"读取 {file_path}", options):
        result.append(msg)
    
    _cache[cache_key] = result
    return result
```

---

## 常见陷阱

### 陷阱 1：路径注入

```python
# ❌ 危险：用户输入直接用于路径
user_input = "../../../etc/passwd"  # 恶意输入
prompt = f"读取 {user_input}"

# ✅ 安全：验证和规范化路径
import os

def safe_path(user_input: str, base_dir: str = ".") -> str:
    """安全地处理路径"""
    # 规范化路径
    full_path = os.path.normpath(os.path.join(base_dir, user_input))
    
    # 确保在基础目录内
    if not full_path.startswith(os.path.abspath(base_dir)):
        raise ValueError("路径逃逸检测")
    
    return full_path
```

### 陷阱 2：命令注入

```python
# ❌ 危险：直接拼接用户输入到命令
filename = "file.txt; rm -rf /"  # 恶意输入
prompt = f"执行: cat {filename}"

# ✅ 安全：验证输入，使用白名单
import re

def validate_filename(filename: str) -> bool:
    """验证文件名安全性"""
    # 只允许字母、数字、点、下划线、连字符
    pattern = r'^[\w\-\.]+$'
    return bool(re.match(pattern, filename))

if validate_filename(filename):
    prompt = f"执行: cat {filename}"
else:
    print("非法文件名")
```

### 陷阱 3：敏感信息泄露

```python
# ❌ 危险：可能读取敏感文件
prompt = "读取所有 .env 文件"

# ✅ 安全：在权限检查中阻止
async def can_use_tool(tool_name, tool_input, context):
    if tool_name == "Read":
        file_path = tool_input.get("file_path", "")
        if ".env" in file_path or "secret" in file_path.lower():
            return PermissionResultDeny(
                behavior="deny",
                message="不允许读取敏感配置文件"
            )
    return PermissionResultAllow(behavior="allow")
```

### 陷阱 4：无限循环

```python
# ❌ 危险：prompt 可能导致无限操作
prompt = "一直监控日志文件直到发现错误"

# ✅ 安全：设置明确的限制
prompt = """
检查最近 100 行日志，如果发现错误则报告，
最多检查 3 次，每次间隔不要执行命令。
"""

# 或在代码层面限制
MAX_ITERATIONS = 10
iteration = 0
async for msg in query(prompt, options):
    iteration += 1
    if iteration > MAX_ITERATIONS:
        break
```

---

## 生产环境清单

### 部署前检查

- [ ] **权限控制**
  - [ ] 实现了 `can_use_tool` 回调
  - [ ] 使用白名单限制允许的操作
  - [ ] 高危操作有确认机制

- [ ] **错误处理**
  - [ ] 所有工具调用有 try-catch
  - [ ] 实现了重试机制
  - [ ] 有超时处理

- [ ] **日志审计**
  - [ ] 记录所有工具调用
  - [ ] 保存操作日志
  - [ ] 可追溯操作历史

- [ ] **资源限制**
  - [ ] 限制最大文件大小
  - [ ] 限制命令执行时间
  - [ ] 限制并发请求数

- [ ] **敏感信息保护**
  - [ ] 禁止读取敏感文件
  - [ ] 禁止写入系统目录
  - [ ] 过滤敏感命令

---

## 总结

### 🔑 核心原则

1. **最小权限**：只授予完成任务所需的最小权限
2. **纵深防御**：多层安全控制
3. **审计追踪**：记录所有操作以便追溯
4. **快速失败**：遇到异常立即停止

### 📋 快速检查

| 检查项 | 通过 |
|--------|------|
| 使用了 `can_use_tool` | ✅/❌ |
| Bash 命令有白名单 | ✅/❌ |
| 敏感文件有保护 | ✅/❌ |
| 有错误处理 | ✅/❌ |
| 有操作日志 | ✅/❌ |

---

## 下一步

✅ 理解了最佳实践后，开始实战：
- **[project_01_file_analyzer](../projects/project_01_file_analyzer/)** - 文件分析器项目
- **[project_02_bash_automation](../projects/project_02_bash_automation/)** - Bash 自动化项目

💡 **提醒**：在实战项目中应用本文档的安全实践！

---

**安全第一，编码愉快！🛡️**
